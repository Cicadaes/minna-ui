<!--
  INPUT TOGGLE COMPONENT

  This component is intended to be an alternative to checkbox inputs in forms
  when there's a need to toggle something with an on and off state. From a UX
  perspective, it should be clearly understood that something is being turned on
  or off.

  An example of this is a switch to turn on or off sound in an interactive web
  app. On the other hand, you should use a checkbox when users are accustomed to
  seeing a checkbox such as an input to accept terms and conditions in a
  transaction flow. That said, most of the time this is a great option.

  USAGE:
    Simply import this component into your vue file and use it in your template
    as if it was a normal input; bind it to a vue model. Example:

      <MinnaToggle bind:value="toggle"/>

    The default toggle is the same size as buttons. If this is too big, you can
    add a "mini" property for a compact version. Example:

      <MinnaToggle bind:value="toggle" mini/>

    It's possible to change the text from "ON"/"OFF" by passing the props textOn
    and textOff. If you change this you may need to modify the width too, which
    can be done via the --toggle-width CSS variable. Example:

      <MinnaToggle bind:value="toggle" textOn="YES" textOff="NO"/>

  TIPS:
    - It's a good idea to add a title attribute so desktop users can understand
      the elements purpose more clearly.
    - If following accessibility guidelines it's recommended to label the
      purpose of the toggle by adding an `aria-label` or `aria-labelledby`
      attribute.
    - If used in a form this component won't send any data by default. If you
      wish to use it as a form input you'll need to bind the v-model to a
      hidden input.
    - The `disabled` attribute is not valid on <div> so we use a class.

  NOTE:
    In the code, object properties starting with __ are safe to mangle; the name
    can be shortened at build time for smaller JavaScript bundles.

-->

<!-- TODO: Ability to drag the toggle using mouse/touch in a high performance way. -->

<div
  class="toggle {mini ? 'toggle-mini' : ''} {disabled !== undefined ? 'toggle-disabled' : ''} {value ? 'toggle-checked' : ''}"
  role="switch"
  tabindex="{disabled === undefined ? 0 : -1}"
  aria-checked="{value}"
  on:click="__toggle()"
  on:keydown="__onKeyDown(event)"
>
  <div class="toggle-slider"/>
  <div class="toggle-on">{textOn}</div>
  <div class="toggle-off">{textOff}</div>
</div>

<script>
  export default {
    data: () => ({
      /* required bind prop */
      // value: true,

      /* optional props */
      textOn: 'ON',
      textOff: 'OFF',
      mini: false,

      /* optional native props */
      disabled: undefined,
      // readonly: false, // TODO: Do we need this prop?
      // required: false, // TODO: Do we need this prop? + // FIXME: Add custom validation
    }),
    methods: {
      __toggle() {
        if (this.get().disabled === undefined) {
          this.set({ value: !this.get().value });
        }
      },
      __onKeyDown(event) {
        // choose key with graceful fallback for old browsers
        switch (event.key || event.keyCode) {
          case 'Enter':
          case 13: // enter
          case ' ':
          case 'Spacebar':
          case 32:
            event.preventDefault(); // don't submit form (enter) or scroll page (space)
            this.__toggle();
            break;
          default:
          // no matching key
        }
      },
    },
  };
</script>

<style type="text/postcss">
  @import "import.css";

  /* TODO: Add documentation explaining how to override these variables using postcss-custom-properties variable overrides */
  :root {
    --toggle-optimize: false;
    --toggle-zindex: 1;
    --toggle-width: 8rem;
    --toggle-padding: var(--button-padding-y) 0;
    --toggle-shadow: var(--button-shadow);
    --toggle-on-text-color: var(--white);
    --toggle-on-background-color: var(--intent-success);
    --toggle-off-text-color: var(--button-text-color);
    --toggle-off-background-color: var(--light-gray1);
    --toggle-inner-shadow: inset 0 -0.125rem 0.6rem color-mod(var(--shadow-color) alpha(0.15));
    --toggle-slider-inner-shadow: inset 0 -1rem 0.4rem color-mod(var(--shadow-color) alpha(0.05));
    --toggle-animate-in-speed: 180ms;
    --toggle-animate-out-speed: 130ms;
    --toggle-hover-slider-background-color: var(--light-gray4);
    --toggle-disabled-text-color: var(--button-disabled-text-color);
    --toggle-disabled-slider-background-color: var(--light-gray3);
    --toggle-disabled-border: 1px solid var(--button-disabled-border-color);
    --toggle-mini-width: calc(var(--toggle-width) / 1.7);
    --toggle-mini-padding: calc(var(--button-padding-y) / 2) 0;
    --toggle-mini-slider-inner-shadow: inset 0 -0.7rem 0.4rem color-mod(var(--shadow-color) alpha(0.05));
  }

  /* the toggle purposely looks like .button and uses many of the button variables */
  .toggle {
    position: relative;
    z-index: var(--toggle-zindex); /* prevent repaint of other elements; promote to new stacking context */
    display: inline-flex;
    width: var(--toggle-width);
    padding: var(--toggle-padding);
    line-height: 1;
    color: var(--toggle-off-text-color);
    text-align: center;
    cursor: pointer;
    background-color: var(--toggle-off-background-color);
    filter: var(--toggle-shadow);
    border-radius: var(--button-radius);
    box-shadow: var(--toggle-inner-shadow);
    transition: background-color var(--toggle-animate-out-speed) ease-out;
    transition-delay: 0s;

    @if var(--toggle-optimize) {
      will-change: background-color;
    }

    &.toggle-mini {
      width: var(--toggle-mini-width);
      padding: var(--toggle-mini-padding);
    }

    &:hover {
      outline: var(--input-hover-outline);
    }

    &:focus {
      outline: var(--input-focus-outline);
    }
  }

  .toggle-checked {
    background-color: var(--toggle-on-background-color);
    transition: background-color var(--toggle-animate-in-speed) ease-in;
    transition-delay: var(--toggle-animate-out-speed);
  }

  .toggle-on,
  .toggle-off {
    flex-basis: calc(var(--toggle-width) / 2);
  }

  .toggle-on {
    color: var(--toggle-on-text-color);

    .toggle-disabled > & {
      color: var(--toggle-disabled-text-color);
    }
  }

  .toggle-slider {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 50%;
    background: var(--button-background-color);
    border-radius: var(--button-radius);
    box-shadow: var(--toggle-slider-inner-shadow);
    transition: transform var(--toggle-animate-in-speed) ease-out;

    @if var(--toggle-optimize) {
      will-change: transform;
    }

    .toggle-checked > & {
      /* FIXME: In chrome/webkit you can see part of .toggle-mini outside the slider */
      transform: translateX(100%);
    }

    .toggle-mini > & {
      box-shadow: var(--toggle-mini-slider-inner-shadow);
    }

    .toggle:hover > &,
    .toggle:focus > & {
      background: var(--toggle-hover-slider-background-color);
    }

    /* stylelint-disable-next-line no-descending-specificity */
    .toggle-disabled > & {
      box-shadow: none; /* inner shadow */
      transition: none;

      @if var(--toggle-optimize) {
        will-change: auto;
      }
    }

    /* stylelint-disable-next-line no-descending-specificity */
    .toggle-disabled > &,
    .toggle-disabled:hover > &,
    .toggle-disabled:focus > & {
      background: var(--toggle-disabled-slider-background-color);
    }
  }

  .toggle-disabled {
    color: var(--button-disabled-text-color);
    cursor: not-allowed;
    background-color: var(--button-background-color);
    filter: none;
    border: var(--toggle-disabled-border);
    box-shadow: none; /* inner shadow */
    transition: none;

    @if var(--toggle-optimize) {
      will-change: auto;
    }

    &:hover,
    &:focus {
      outline: none;
    }
  }
</style>
